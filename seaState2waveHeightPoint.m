function eta=seaState2waveHeightPoint(beta, t, muVec, dmu, wVec, dw, e, x, y, S)
% SEASTATE2WAVEHEIGHTPOINT Takes in sea state and plots a wave height. Uses the 
% Bretschneider spectrum.
%
% Inputs:
%   - seaState: integer in interval [1, 9].
%   - beta:     direction of main wave in rad.
%   - t:        double. point in time
%   - muVec:    angle directions vector. E.g.: -pi/2:dmu:pi/2. If muVec=[],
%               then the waves generated will be one-directional (long-
%               crested).
%   - dmu:      direction interval taken in muVec. Used if muVec ~= [].
%   - wVec:     vector containing the frequencies
%   - dw:       the difference between each frequency in wVec
%   - e:        the random phases of the waves.
%   - x:        the x coordinate
%   - y:        the y coordinte
%   - S:        The spectral density vector generated by the function
%               "creteSpectrum"
%
% Ouput:
%   - eta:      The wave height at point (x,y) at time t


g = 9.81;
% Get the wave heights for all coordinates (x,y) for time t.
% For each coordinate (x,y), sum the contribution of all the waves
% to get the final wave amplitude at that point = sumOfWaves.
sumOfWaves = 0;
for k=1:length(wVec)
    w_k = wVec(k);
    if isempty(muVec) % Long-crested
        coeff = w_k ^ 2 / g;
        e_k = e(k);
        amp = sqrt(2 * S(k) * dw);
        wave = amp * cos(coeff * (x * cos(-beta) ...
                       + y * sin(-beta))  ...
                                  - w_k * t + e_k);
        sumOfWaves = sumOfWaves + wave; 
    else              % Short-crested
        for i=1:length(muVec)
            e_ik = e(i, k);
            mu_i = muVec(i);
            amp = sqrt(2 * S(k) * spread(mu_i) * dw * dmu);
            wave = amp * cos(w_k^2/g * (x * cos(mu_i - beta) ...
                           + y * sin(mu_i - beta))  ...
                                      - w_k * t + e_ik);
            sumOfWaves = sumOfWaves + wave;                
        end 
    end
end
eta = sumOfWaves;


% ----------------------- Help functions ----------------------------------

function spreadFunction=spread(mu)
    if (mu >= -pi/2 && mu <= pi/2)
        spreadFunction = (2 / pi) * cos(mu)^2;
    else
        spreadFunction = 0;
    end
end
end
